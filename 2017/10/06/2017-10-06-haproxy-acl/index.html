<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="澳门新葡京"><title>Haproxy acl | 天天反水, 美女荷官发牌   ---澳门新葡京</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Haproxy acl</h1><a id="logo" href="/.">天天反水, 美女荷官发牌   ---澳门新葡京</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Haproxy acl</h1><div class="post-meta">Oct 6, 2017<span> | </span><span class="category"><a href="/categories/Haprxoy/">Haprxoy</a></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Haproxy-Acl"><span class="toc-number">1.</span> <span class="toc-text">Haproxy Acl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例配置"><span class="toc-number">1.2.</span> <span class="toc-text">示例配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">1.3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码跟踪"><span class="toc-number">1.4.</span> <span class="toc-text">代码跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#acl"><span class="toc-number">1.4.1.</span> <span class="toc-text">acl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use-backend-后端选择"><span class="toc-number">1.4.2.</span> <span class="toc-text">use_backend 后端选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map的使用"><span class="toc-number">1.4.3.</span> <span class="toc-text">map的使用</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1 id="Haproxy-Acl"><a href="#Haproxy-Acl" class="headerlink" title="Haproxy Acl"></a>Haproxy Acl</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">acl:Access Control Lists 访问控制列表</span><br><span class="line"></span><br><span class="line">acl格式如下所示：</span><br><span class="line">    acl &lt;aclname&gt; &lt;criterion&gt; [flags] [operator] [&lt;value&gt;]</span><br><span class="line">    aclname: acl名字，在后面的条件表达式中引用</span><br><span class="line">    criterion: 样本提取方法，从请求或者响应内容中提取值，</span><br><span class="line">               如hdr(host)，从http头部提取host字段的值</span><br><span class="line">    flags: 匹配标志，-i 忽略大小写，-m str匹配字符串，</span><br><span class="line">           -f从文件读取值等</span><br><span class="line">    operator: 方法，匹配整形时，eq方法表示等于</span><br><span class="line">    value: 具体匹配的值，可以是多个，匹配整形时 “1 2 3”，</span><br><span class="line">           匹配字符串时“netease.com baidu.com”</span><br></pre></td></tr></table></figure>
<h2 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//以下所有的解释都基于下面的acl规则</span><br><span class="line"></span><br><span class="line">    //定义三个acl</span><br><span class="line">    //1 http host为netease.com，baidu.com，ali.com，转换成小写匹配</span><br><span class="line">    acl host_acl hdr(host),lower  -m str netease.com baidu.com ali.com</span><br><span class="line">    </span><br><span class="line">    //2 http path 是以 /index.html 开头</span><br><span class="line">    acl path_acl path_beg /index.html</span><br><span class="line">    </span><br><span class="line">    //3 http version为 1.1</span><br><span class="line">    acl head_acl hdr(version) -m str 1.1</span><br><span class="line">    </span><br><span class="line">    //条件 (host_acl &amp;&amp; (!head_acl))  || path_acl满足时，使用test1后端</span><br><span class="line">    use_backend test1 if host_acl !head_acl or path_acl</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">//acl关键字解析，例如hdr，path等</span><br><span class="line">struct acl_keyword &#123;</span><br><span class="line">  //关键字名称，hdr</span><br><span class="line">  const char *kw;</span><br><span class="line">  //提取关键字名字，多个acl关键字对应的提取关键字一样，例如hdr，hdr_beg, hdr_dir都对应req.hdr</span><br><span class="line">  char *fetch_kw; </span><br><span class="line">  /* Contain PAT_MATCH_* */ //匹配类型，可以是int，bool，str，ip等</span><br><span class="line">  int match_type; </span><br><span class="line">  //解析字段，例如hdr(host)，调用pat_parse_str把host字段保存起来</span><br><span class="line">  int (*parse)(const char *text, struct pattern *pattern, int flags, char **err);</span><br><span class="line"></span><br><span class="line">  //把需要匹配的值保存链接起来，baidu.com，netease.com ali.com</span><br><span class="line">  int (*index)(struct pattern_expr *expr, struct pattern *pattern, char **err);</span><br><span class="line">  void (*delete)(struct pattern_expr *expr, struct pat_ref_elt *);</span><br><span class="line">  void (*prune)(struct pattern_expr *expr);</span><br><span class="line">  //acl执行时的匹配函数</span><br><span class="line">  struct pattern *(*match)(struct sample *smp, struct pattern_expr *expr, int fill);</span><br><span class="line">  /* must be after the config params */</span><br><span class="line">  /* the sample fetch we depend on */ //样本提取结构体</span><br><span class="line">  struct sample_fetch *smp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct acl &#123;</span><br><span class="line">    //假如多个acl组成一个逻辑且的表达式，通过这个list链接起来</span><br><span class="line">    struct list list;  </span><br><span class="line">    char *name; //acl名字</span><br><span class="line">    struct list expr; //acl表达式</span><br><span class="line">    int cache_idx;</span><br><span class="line">    unsigned int use;</span><br><span class="line">    unsigned int val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//acl表达式</span><br><span class="line">struct acl_expr &#123;</span><br><span class="line">    //样本提取结构，例如从http头部数据的提起，获得host字段的值等</span><br><span class="line">    struct sample_expr *smp; </span><br><span class="line">    //样本提取以后，具体的匹配函数，对应acl_keyword中的函数指针</span><br><span class="line">    struct pattern_head pat; </span><br><span class="line">    //名字相同的acl可以包含多个acl_expr，通过链表连接起来</span><br><span class="line">    struct list list;</span><br><span class="line">    //acl名字</span><br><span class="line">    const char *kw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//acl_keyword中的匹配函数</span><br><span class="line">struct pattern_head &#123;</span><br><span class="line">  int (*parse)(const char *text, struct pattern *pattern, int flags, char **err);</span><br><span class="line">  int (*parse_smp)(const char *text, struct sample_data *data);</span><br><span class="line">  int (*index)(struct pattern_expr *, struct pattern *, char **);</span><br><span class="line">  void (*delete)(struct pattern_expr *, struct pat_ref_elt *);</span><br><span class="line">  void (*prune)(struct pattern_expr *);</span><br><span class="line">  struct pattern *(*match)(struct sample *, struct pattern_expr *, int);</span><br><span class="line">  //样本提取出来的类型</span><br><span class="line">  int expect_type; /* type of the expected sample (SMP_T_*) */</span><br><span class="line"></span><br><span class="line">  struct list head; /* This is a list of struct pattern_expr_list. */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//主要是与pat_ref的一些结合</span><br><span class="line">struct pattern_expr &#123;</span><br><span class="line">  struct list list; /* Used for chaining pattern_expr in pat_ref. */</span><br><span class="line">  unsigned long long revision; /* updated for each update */</span><br><span class="line">  struct pat_ref *ref; /* The pattern reference if exists. */</span><br><span class="line">  struct pattern_head *pat_head; /* Point to the pattern_head that contain manipulation functions.</span><br><span class="line">                                  * Note that this link point on compatible head but not on the real</span><br><span class="line">                                  * head. You can use only the function, and you must not use the</span><br><span class="line">                                  * &quot;head&quot;. Dont write &quot;(struct pattern_expr *)any-&gt;pat_head-&gt;expr&quot;.</span><br><span class="line">                                  */</span><br><span class="line">  //这个就是配置文件中的值，在示例中为netease.com ,baidu.com这几个值的一个链表</span><br><span class="line">  struct list patterns;         /* list of acl_patterns */ </span><br><span class="line">  struct eb_root pattern_tree;  /* may be used for lookup in large datasets */</span><br><span class="line">  struct eb_root pattern_tree_2;  /* may be used for different types */</span><br><span class="line">  int mflags;                     /* flags relative to the parsing or matching method. */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//一个acl项，其中neg为表示在使用acl时，前面是否带了逻辑非“！”</span><br><span class="line">struct acl_term &#123;</span><br><span class="line">  struct list list;           /* chaining */ //所有逻辑与的acl通过这个链接起来</span><br><span class="line">  struct acl *acl;            /* acl pointed to by this term */</span><br><span class="line">  int neg;                    /* 1 if the ACL result must be negated */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//一个条件中，逻辑与的表达式通过这个结构体表示，</span><br><span class="line">//示例中host_acl !head_acl 和 path_acl通过两个结构体表示</span><br><span class="line">struct acl_term_suite &#123;</span><br><span class="line">  struct list list;           /* chaining of term suites */</span><br><span class="line">  struct list terms;          /* list of acl_terms */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//条件，多个acl组成，use_backend if host_acl，通过一个acl_cond组成</span><br><span class="line">struct acl_cond &#123;</span><br><span class="line">  struct list list;           /* Some specific tests may use multiple conditions */</span><br><span class="line">  struct list suites;         /* list of acl_term_suites */</span><br><span class="line">  enum acl_cond_pol pol;      /* polarity: ACL_COND_IF / ACL_COND_UNLESS */</span><br><span class="line">  unsigned int use;           /* or&apos;ed bit mask of all suites&apos;s SMP_USE_* */</span><br><span class="line">  unsigned int val;           /* or&apos;ed bit mask of all suites&apos;s SMP_VAL_* */</span><br><span class="line">  const char *file;           /* config file where the condition is declared */</span><br><span class="line">  int line;                   /* line in the config file where the condition is declared */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="代码跟踪"><a href="#代码跟踪" class="headerlink" title="代码跟踪"></a>代码跟踪</h2><h3 id="acl"><a href="#acl" class="headerlink" title="acl"></a>acl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//acl表达式，hdr为于proto_http.c中定义，会在程序初始化时注册到全局变量中</span><br><span class="line">static struct acl_kw_list acl_kws = &#123;ILH, &#123;</span><br><span class="line">    //hdr没有声明pattern_head中的函数，会直接调用req.hdr 样本提取结构中的匹配，检验等函数</span><br><span class="line">    &quot;hdr&quot;,             &quot;req.hdr&quot;,  PAT_MATCH_STR &#125;, </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//smp_fetch_hdr用于从http从提取头部的函数，ARG2(0,STR,SINT)表示最少0个参数，</span><br><span class="line">//最多两个参数，并且参数类型分别是长度，和整形，所以可以这么声明hdr(host, 10)，</span><br><span class="line">//提取host前10个字符串, 一个参数的mask由一个32位的整形表示，</span><br><span class="line">//其中第三位代表参数的最少个数个数，后面的25位每5位代表一个参数，</span><br><span class="line">//5位最大代表31中类型，所以现在的内置函数最多支持5个参数，31中内置类型，</span><br><span class="line">//可以参考include/types/arg.h 和include/proto/arg.h src/arg.c的实现</span><br><span class="line"></span><br><span class="line">static struct sample_fetch_kw_list sample_fetch_keywords = &#123;ILH, &#123;</span><br><span class="line">&#123; &quot;req.hdr&quot;,         smp_fetch_hdr,            ARG2(0,STR,SINT), val_hdr, SMP_T_STR,  SMP_USE_HRQHV &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cfg_parse_listen(const char *file, int linenum, char **args, int kwm):cfgparse.c:3193</span><br><span class="line">    //遇到acl关键字，进入acl分支中</span><br><span class="line">    parse_acl：acl.c:712</span><br><span class="line">        parse_acl_expr: acl.c:134</span><br><span class="line">            aclkw = find_acl_kw(args[0]); //查找acl关键字，示例中是&quot;hdr&quot;</span><br><span class="line">            smp = calloc(1, sizeof(struct sample_expr)); //创建样本提取表达式</span><br><span class="line">            LIST_INIT(&amp;(smp-&gt;conv_exprs)); //样本提取可以有转换表达式，示例中的lower</span><br><span class="line">            smp-&gt;fetch = aclkw-&gt;smp; //保存样本提取的表达式</span><br><span class="line">            smp-&gt;arg_p = empty_arg_list; //参数列表</span><br><span class="line">            for (arg = args[0]; *arg &amp;&amp; *arg != &apos;(&apos; &amp;&amp; *arg != &apos;,&apos;; arg++); //参数列表是以“(”和“,”为分隔符</span><br><span class="line">            </span><br><span class="line">            endt = arg; </span><br><span class="line">            //找到参数列表的结束符)&quot;</span><br><span class="line">            if (*endt == &apos;(&apos;) &#123;</span><br><span class="line">              /* look for the end of this term and skip the opening parenthesis */</span><br><span class="line">              endt = ++arg;</span><br><span class="line">              while (*endt &amp;&amp; *endt != &apos;)&apos;) </span><br><span class="line">                endt++;</span><br><span class="line">              if (*endt != &apos;)&apos;) &#123;</span><br><span class="line">                memprintf(err, &quot;missing closing &apos;)&apos; after arguments to ACL keyword &apos;%s&apos;&quot;, aclkw-&gt;kw);</span><br><span class="line">                goto out_free_smp;</span><br><span class="line">              &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //创建参数列表，这里很很有技巧，所有的参数都会存入arg_p中，列表类型，arg_mask就是上面说的那个32位的整数</span><br><span class="line">            nbargs = make_arg_list(arg, endt - arg, smp-&gt;fetch-&gt;arg_mask, &amp;smp-&gt;arg_p,</span><br><span class="line">                           err, NULL, NULL, al); </span><br><span class="line">                </span><br><span class="line">            //省略转换部分参数解析，例如language(es;fr;en)这个参数转换函数的参数解析</span><br><span class="line">            ....</span><br><span class="line">            </span><br><span class="line">            //创建acl_expr</span><br><span class="line">            expr = (struct acl_expr *)calloc(1, sizeof(*expr));</span><br><span class="line">            //根据参数类型，设置匹配，解析，函数，上面的hdr没有定义自己的函数</span><br><span class="line">            //所以用match_type在全局变量pat_pars_fcts中找</span><br><span class="line">            expr-&gt;pat.parse  = aclkw-&gt;parse  ? aclkw-&gt;parse  : pat_parse_fcts[aclkw-&gt;match_type]; </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //接下来解析-m str baidu.com netease.com等部分，把baidu.com存入arg中</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //会调用index函数，把baidu.com存入pat_expr的pattern_list，</span><br><span class="line">            //这几个值是逻辑或的关系，后续判断acl是否匹配是，只要匹配一个值即可</span><br><span class="line">            if (!pat_ref_add(ref, arg, NULL, err))</span><br><span class="line">        </span><br><span class="line">        //回到parse_acl函数，根据acl名字在这个proxy中查找已经存在的acl，</span><br><span class="line">        //如果存在，直接通过链表连接起来即可，后续判断所有acl是逻辑与的关系</span><br><span class="line">        if (*args[0])</span><br><span class="line">          cur_acl = find_acl_by_name(args[0], known_acl);                                                                                   </span><br><span class="line">        else</span><br><span class="line">          cur_acl = NULL;</span><br></pre></td></tr></table></figure>
<h3 id="use-backend-后端选择"><a href="#use-backend-后端选择" class="headerlink" title="use_backend 后端选择"></a>use_backend 后端选择</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//配置解析</span><br><span class="line">cfg_parse_listen(const char *file, int linenum, char **args, int kwm):cfgparse.c:3803</span><br><span class="line">    //先判断是 逻辑 “是” 或者 “非”</span><br><span class="line">    if (strcmp(args[2], &quot;if&quot;) == 0 || strcmp(args[2], &quot;unless&quot;) == 0)</span><br><span class="line">        //构建acl_cond</span><br><span class="line">        build_acl_cond：acl.c:1056</span><br><span class="line">          parse_acl_cond：acl.c:900</span><br><span class="line">          //函数比较简单，创建acl_cond，指定pol字段到底是if还是unless</span><br><span class="line">          //对于or字段前面的所有acl，每个acl创建一个acl_term来保存，acl_term的neg表示前面是否有!</span><br><span class="line">          //对于or字段前面的所有acl，创建acl_term_suit连接起来</span><br><span class="line">          //对于所有or作为分隔符的acl，判断时是逻辑与的关系，每个or就是一个acl_term_suit，</span><br><span class="line">          //通过acl_cond的suitel字段连接</span><br><span class="line">            </span><br><span class="line">    //每个use_backend通过一个switching_rule表示，通过proxy的switching_rules连接起来</span><br><span class="line">    rule = (struct switching_rule *)calloc(1, sizeof(*rule));</span><br><span class="line">    rule-&gt;cond = cond;</span><br><span class="line">    rule-&gt;be.name = strdup(args[1]);</span><br><span class="line">    LIST_INIT(&amp;rule-&gt;list);</span><br><span class="line">    LIST_ADDQ(&amp;curproxy-&gt;switching_rules, &amp;rule-&gt;list);</span><br><span class="line"></span><br><span class="line">//后端选择</span><br><span class="line">static int process_switching_rules(struct stream *s, struct channel *req, int an_bit):stream.c:1112</span><br><span class="line">    //对于每个use_backend轮询处理，如果遇到合适的，直接匹配，</span><br><span class="line">    //所以haproxy就是简单的根据声明顺序，优先匹配</span><br><span class="line">    list_for_each_entry(rule, &amp;fe-&gt;switching_rules, list) &#123;</span><br><span class="line">        acl_exec_cond：acl.c:1102</span><br><span class="line">            //遍历acl_cond的每个suites，suites只要匹配一个即可</span><br><span class="line">            list_for_each_entry(suite, &amp;cond-&gt;suites, list) &#123;</span><br><span class="line">                //遍历suites中所有的acl，需要所有的acl都满足</span><br><span class="line">                list_for_each_entry(term, &amp;suite-&gt;terms, list) &#123;</span><br><span class="line">                    //每个acl都由多个acl_expr组成，遍历，需要全部满足</span><br><span class="line">                    list_for_each_entry(expr, &amp;acl-&gt;expr, list) &#123;</span><br><span class="line">                        //提取请求中需要做判断的字段</span><br><span class="line">                        sample_process(px, sess, strm, opt, expr-&gt;smp, &amp;smp)</span><br><span class="line">                        //调用pattern_exec_match判断</span><br><span class="line">                        acl_res |= pat2acl(pattern_exec_match(&amp;expr-&gt;pat, &amp;smp, 0));</span><br><span class="line"></span><br><span class="line">struct pattern *pattern_exec_match(struct pattern_head *head, struct sample *smp, int fill)</span><br><span class="line">    //先进行转换，例如lower函数执行等</span><br><span class="line">    if (!sample_convert(smp, head-&gt;expect_type))</span><br><span class="line">    </span><br><span class="line">    //对每组进行匹配？这个链表暂时没看出来什么意思</span><br><span class="line">    list_for_each_entry(list, &amp;head-&gt;head, list) &#123;</span><br><span class="line">        pat = head-&gt;match(smp, list-&gt;expr, fill);</span><br><span class="line">        //对于PAT_MATCH_STR类型，调用</span><br><span class="line">            pat_match_str：</span><br><span class="line">                //遍历每个参数，baidu.com，netease.com等，只要满足一个即可</span><br><span class="line">                list_for_each_entry(lst, &amp;expr-&gt;patterns, list) &#123;</span><br><span class="line">        if (pat)</span><br><span class="line">          return pat;</span><br></pre></td></tr></table></figure>
<h3 id="map的使用"><a href="#map的使用" class="headerlink" title="map的使用"></a>map的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">acl 使用-f选项时，从指定文件中加载， -M选项时，从文件中读取key/value，没有指定时，单纯加载一个值</span><br><span class="line"></span><br><span class="line">acl 的convert部分可以使用map，例如：</span><br><span class="line">把host当做key，到文件/etc/test取值出来 去匹配</span><br><span class="line">文件内容：</span><br><span class="line">netease.com 100</span><br><span class="line">baidu.com 20</span><br><span class="line"></span><br><span class="line">acl格式如下：</span><br><span class="line">acl test hdr(host),map(/etc/test) gt 10</span><br><span class="line"></span><br><span class="line">http-request中也可以使用map</span><br><span class="line">del-map(&lt;file name&gt;) &lt;key fmt&gt; |</span><br><span class="line">set-map(&lt;file name&gt;) &lt;key fmt&gt; &lt;value fmt&gt;</span><br><span class="line"></span><br><span class="line">key fmt和 value fmt可以使用日志中的变量，例如%[src] 也可以是提取函数，%[res.hdr(X-Value)]等</span><br><span class="line"></span><br><span class="line">所有map文件都使用pat_ref结构保存起来，并且链接到一个全局变量中，例如在文件名字相同的情况下</span><br><span class="line">http-request使用set-map，会更新到acl中的map中</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Haproxy/">Haproxy</a><a href="/tags/负载均衡/">负载均衡</a></div><div class="post-nav"><a href="/2017/10/07/2017-10-07-haproxy-stick-table/" class="pre">Haproxy stick table</a><a href="/2017/10/05/2017-10-05-haproxy-start/" class="next">Haproxy 启动流程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Haprxoy/">Haprxoy</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Https/">Https</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tcp-ip/">tcp/ip</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Haproxy/" style="font-size: 15px;">Haproxy</a> <a href="/tags/负载均衡/" style="font-size: 15px;">负载均衡</a> <a href="/tags/Https/" style="font-size: 15px;">Https</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/dpdk/" style="font-size: 15px;">dpdk</a> <a href="/tags/dpvs/" style="font-size: 15px;">dpvs</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/2018-12-04-netif-init/">dpvs大部分知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/2018-12-04-dpvs-timer/">dpvs timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/02/2018-12-2-kni/">dpdk kni</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/01/2018-12-01-pci-init/">dpdk网卡收发包</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/29/2018-11-29-dpdk-memory/">dpdk 内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/2018-11-26-dpdk-init/">dpdk rte init</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/2018-11-07-numa/">dpdk基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/2018-11-06-dpdk-framework/">dpdk 基本框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/12/2018-04-12-haproxy-port-reuse/">Haproxy 端口复用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/2018-02-26-netfilter/">netfilter 框架及lvs的实现原理</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">天天反水, 美女荷官发牌   ---澳门新葡京.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>