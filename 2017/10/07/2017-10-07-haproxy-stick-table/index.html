<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="澳门新葡京"><title>Haproxy stick table | 天天反水, 美女荷官发牌   ---澳门新葡京</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Haproxy stick table</h1><a id="logo" href="/.">天天反水, 美女荷官发牌   ---澳门新葡京</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Haproxy stick table</h1><div class="post-meta">Oct 7, 2017<span> | </span><span class="category"><a href="/categories/Haprxoy/">Haprxoy</a></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Haproxy-Stick-Table-原理"><span class="toc-number">1.</span> <span class="toc-text">Haproxy Stick Table 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例"><span class="toc-number">1.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">1.3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码跟踪"><span class="toc-number">1.4.</span> <span class="toc-text">代码跟踪</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="Haproxy-Stick-Table-原理"><a href="#Haproxy-Stick-Table-原理" class="headerlink" title="Haproxy Stick Table 原理"></a>Haproxy Stick Table 原理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">stick-table 中文翻译&quot;粘表&quot;，最开始设计初衷是对于有相同标志的多个请求，请求转发到同一个后端。</span><br><span class="line"> 后面扩大了一些功能，可以用来做数据统计，限速攻击拦截等，所以在使用中，第一反应是很乱，本文从配置</span><br><span class="line"> 入手，分析一个比较典型的例子，再说明其源码的实现。</span><br><span class="line"> </span><br><span class="line"> stick-table type &#123;ip | integer | string [len &lt;length&gt;] | binary [len &lt;length&gt;]&#125;</span><br><span class="line">         size &lt;size&gt; [expire &lt;expire&gt;] [nopurge] [peers &lt;peersect&gt;]</span><br><span class="line">         [store &lt;data_type&gt;]</span><br><span class="line">         </span><br><span class="line"> 这是一个stick-table的定义，每个frontend，backend，listen都可以定义一个stick-table，名字是frontend</span><br><span class="line"> 等的名字，type是stick-table存储的key的类型，store是额外存储的字段，其中server_id也就是后端服务器</span><br><span class="line"> 的id是默认存储的。额外存储的字段例如conn_cnt，连接总数，单调递增；http_req_rate(10s) 10s内http</span><br><span class="line"> 请求的速度。</span><br><span class="line"> </span><br><span class="line"> stick on &lt;pattern&gt; [table &lt;table&gt;] [&#123;if | unless&#125; &lt;condition&gt;]    </span><br><span class="line"> 匹配和保存，根据pattern提取出来的值作为key，去table查找后端，如果查找到就使用</span><br><span class="line"> 请求完成以后，把后端，以及额外要保存的值保存到table中</span><br><span class="line"> pattern： 是样本提取函数，参考前面acl一节</span><br><span class="line"> table： table名字，可以在一个后端中引用另外一个后端的table</span><br><span class="line"> condition： 满足这个条件才会进行匹配和保存</span><br><span class="line"> </span><br><span class="line"> stick match &lt;pattern&gt; [table &lt;table&gt;] [&#123;if | unless&#125; &lt;cond&gt;]</span><br><span class="line"> 单纯匹配后端，不保存本次的结果</span><br><span class="line"> </span><br><span class="line"> stick store-request &lt;pattern&gt; [table &lt;table&gt;] [&#123;if | unless&#125; &lt;condition&gt;]</span><br><span class="line"> stick store-response &lt;pattern&gt; [table &lt;table&gt;] [&#123;if | unless&#125; &lt;condition&gt;]</span><br><span class="line"> 单纯保存，不进行匹配</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> http-request &#123; track-sc0 | track-sc1 | track-sc2 &#125; &lt;key&gt; [table &lt;table&gt;] |</span><br><span class="line">           sc-inc-gpc0(&lt;sc-id&gt;) |</span><br><span class="line">           sc-set-gpt0(&lt;sc-id&gt;) &lt;int&gt; </span><br><span class="line"> tcp-request content  track-sc0 | track-sc1 | track-sc2 &#125; &lt;key&gt; [table &lt;table&gt;] |</span><br><span class="line">           sc-inc-gpc0(&lt;sc-id&gt;) |</span><br><span class="line">           sc-set-gpt0(&lt;sc-id&gt;) &lt;int&gt; </span><br><span class="line">           </span><br><span class="line"> 在http-request和tcp-request中，也会有stick-table的使用，主要用于跟踪值，增加gpc值等，</span><br><span class="line"> 其中key表示样本提取方法，用来从请求当中提取主键，可以这么使用：</span><br><span class="line"> http-request track-sc2 hdr(host)</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">google haproxy stick-table的使用，总是会遇到一篇文章，说实话，</span><br><span class="line">这个示例很乱，没有说清楚， 反而带来很多困扰</span><br><span class="line">http://blog.serverfault.com/2010/08/26/1016491873/（英文）</span><br><span class="line">http://blog.sina.com.cn/s/blog_704836f40101f6qz.html (中文翻译)</span><br><span class="line">本文也以这个为示例:</span><br><span class="line">    </span><br><span class="line">global</span><br><span class="line">   log 127.0.0.1   local0</span><br><span class="line">   log 127.0.0.1   local1 notice</span><br><span class="line">   stats socket /var/run/haproxy.stat mode 600 level operator</span><br><span class="line">   maxconn 4096</span><br><span class="line">   user haproxy</span><br><span class="line">   group haproxy</span><br><span class="line">#   daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">   log global</span><br><span class="line">   mode http</span><br><span class="line">   option httplog</span><br><span class="line">   option dontlognull</span><br><span class="line">   retries 3</span><br><span class="line">   option redispatch</span><br><span class="line">   maxconn 2000</span><br><span class="line"></span><br><span class="line">backend test1</span><br><span class="line">   stick-table type ip size 200k expire 10m store conn_rate(100s),bytes_out_rate(60s),gpc0</span><br><span class="line">     # values below are specific to the backend</span><br><span class="line">     tcp-request content track-sc2 src </span><br><span class="line">     acl conn_rate_abuse sc2_conn_rate gt 3</span><br><span class="line"></span><br><span class="line">     # abuse is marked in the frontend so that it&apos;s shared between all sites</span><br><span class="line">     acl mark_as_abuser sc1_inc_gpc0 gt 0</span><br><span class="line">     tcp-request content reject if conn_rate_abuse mark_as_abuser</span><br><span class="line">     server local_apache localhost:80</span><br><span class="line"></span><br><span class="line">  backend ease-up-y0</span><br><span class="line">      mode http</span><br><span class="line">      errorfile 503 /etc/haproxy/errors/503.http</span><br><span class="line"></span><br><span class="line">frontend http</span><br><span class="line">   bind *:2550</span><br><span class="line">   stick-table type ip size 200k expire 10m store gpc0</span><br><span class="line">   # check the source before tracking counters, that will allow it to</span><br><span class="line">   # expire the entry even if there is still activity.</span><br><span class="line">   acl source_is_abuser src_get_gpc0 gt 0</span><br><span class="line">   acl is_test1 hdr_sub(host) -i test1.com</span><br><span class="line">   tcp-request connection track-sc1 src if !source_is_abuser</span><br><span class="line"></span><br><span class="line">   use_backend ease-up-y0 if source_is_abuser</span><br><span class="line">   use_backend test1 if is_test1</span><br><span class="line">   </span><br><span class="line">   这个实例我精简了一下，现在主要作用是是：</span><br><span class="line">   1 host=test1.com 的使用backend test1后端</span><br><span class="line">   2 对于gpc0 大于 0的，使用ease-up-y0后端，返回503</span><br><span class="line">   3 100s内，连接速度超过3个，拒绝连接，并且标记增加gpc0的值</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//每个key的数据结构， 所有的值都存储在后面</span><br><span class="line">struct stksess &#123;</span><br><span class="line">  unsigned int expire;      /* session expiration date */</span><br><span class="line">  unsigned int ref_cnt;     /* reference count, can only purge when zero */</span><br><span class="line">  struct eb32_node exp;     /* ebtree node used to hold the session in expiration tree */</span><br><span class="line">  struct eb32_node upd;     /* ebtree node used to hold the update sequence tree */</span><br><span class="line">  //连接到stktable的keys中</span><br><span class="line">  struct ebmb_node key;     /* ebtree node used to hold the session in table */</span><br><span class="line">  /* WARNING! do not put anything after &lt;keys&gt;, it&apos;s used by the key */</span><br><span class="line">  //例如：gpc0，server_id等值都是存储在最后面的这块内存里面，Linux常见手法</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//单个stick-table的数据结构，这里省略了很多字段</span><br><span class="line">struct stktable &#123;</span><br><span class="line">  //使用eb_root存储key</span><br><span class="line">  struct eb_root keys;      /* head of sticky session tree */</span><br><span class="line">  struct eb_root exps;      /* head of sticky session expiration tree */</span><br><span class="line">  //存储额外字段的总大小，也就是在分配上面的stksess的时候，需要多分配data_size大小的内存</span><br><span class="line">  int data_size; /* the size of the data that is prepended *before* stksess */</span><br><span class="line">  //每种存储类型与stkses的距离offset，为0代表不需要存储这种类型，</span><br><span class="line">  //类型包括server_id,gpt0，gpc0,conn_cnt等</span><br><span class="line">  int data_ofs[STKTABLE_DATA_TYPES]; /* negative offsets of present data types, or 0 if absent */</span><br><span class="line">  //每种类型的参数，例如速率相关的都有个时间，conn_rate(100s)，这个100s就保存在这里</span><br><span class="line">  union &#123;</span><br><span class="line">    int i;</span><br><span class="line">    unsigned int u;</span><br><span class="line">    void *p;</span><br><span class="line">  &#125; data_arg[STKTABLE_DATA_TYPES]; /* optional argument of each data type */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当前strem正在跟踪的条目，entry是stksess的地址强转为unsigned long类型</span><br><span class="line">struct stkctr &#123;</span><br><span class="line">  unsigned long entry;  /* entry containing counters currently being tracked by this stream  */</span><br><span class="line">  struct stktable *table; /* table the counters above belong to (undefined if counters are null) */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//stream 与本节相关的内容</span><br><span class="line">struct stream &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  //需要保存的数据，一开始先标记，等后面例如server_id等赋值以后，</span><br><span class="line">  //再从这里取出来保存，顺便增加conn_cnt等值</span><br><span class="line">  struct &#123;</span><br><span class="line">    struct stksess *ts;</span><br><span class="line">    struct stktable *table;</span><br><span class="line">  &#125; store[8];                     /* tracked stickiness values to store */</span><br><span class="line">  int store_count;</span><br><span class="line">  </span><br><span class="line">  //这里困扰了我很久的一个问题，上面示例中的src_get_gpc0在frontend中声明，</span><br><span class="line">  //默认使用的是http表，在backend中sc1_inc_gpc0 默认使用的是test1表，</span><br><span class="line">  //两个表都可以独立的统计gpc0，一点关联都没有，不可能达到配置的目的，后来</span><br><span class="line">  //通过查看代码发现，在一个stream中，针对sc0 sc1 sc2这三个标记，会在stkctr数组中保存</span><br><span class="line">  //因为一个frontend和一个backend属于同一个stream，又在http中，track-sc1的时候，已经</span><br><span class="line">  //初始化了stkctr[1]-&gt;table = http，所以在backend test1中，会从这数组中取出http table来</span><br><span class="line">  //使用，增加gpc0的值</span><br><span class="line">  struct stkctr stkctr[MAX_SESS_STKCTR];</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//与本节内容弄有关的还有tcp-request http-request等，这些保存在proxy中</span><br><span class="line">struct proxy &#123;</span><br><span class="line">  //&quot;http_request&quot;</span><br><span class="line">  struct list http_req_rules;   /* HTTP request rules: allow/deny/... */</span><br><span class="line">  //&quot;http_response&quot;</span><br><span class="line">  struct list http_res_rules;   /* HTTP response rules: allow/deny/... */</span><br><span class="line">  //&quot;stick match&quot; &quot;stick store&quot; &quot;stick on&quot;</span><br><span class="line">  struct list sticking_rules;             /* content sticking rules (chained) */</span><br><span class="line">  struct list storersp_rules;             /* content store response rules (chained) */</span><br><span class="line">  </span><br><span class="line">  // &quot;tcp_request&quot;</span><br><span class="line">  struct tcp_req &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  //&quot;tcp_response&quot;</span><br><span class="line">  struct tcp_rep &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码跟踪"><a href="#代码跟踪" class="headerlink" title="代码跟踪"></a>代码跟踪</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//tcp-request connection 是在session处理阶段，accept中处理的，stream中的strctr会从session中继承下来</span><br><span class="line">//tcp-request content 是在已经分配了stream，在stream中处理的</span><br><span class="line"></span><br><span class="line">tcp-request connection track-sc1 src if !source_is_abuser</span><br><span class="line"></span><br><span class="line">首先在frontend的http表中，gpc0初始值为0，所以会进入track-sc1流程，tcp-request属于上面的tcp_req</span><br><span class="line">规则的一部分，所以会在tcp_exec_req_rules函数中处理</span><br><span class="line">  tcp_exec_req_rules：</span><br><span class="line">    ......</span><br><span class="line">    //首先执行acl的conditon，条件满足以后，会判断rule的action</span><br><span class="line">    if (rule-&gt;action &gt;= ACT_ACTION_TRK_SC0 &amp;&amp; rule-&gt;action &lt;= ACT_ACTION_TRK_SCMAX) &#123;</span><br><span class="line">      /* Note: only the first valid tracking parameter of each</span><br><span class="line">      * applies.</span><br><span class="line">      */</span><br><span class="line">      struct stktable_key *key;</span><br><span class="line">      </span><br><span class="line">      //判断是不是第一次进去，不是的话，返回非空，直接返回</span><br><span class="line">      if (stkctr_entry(&amp;sess-&gt;stkctr[tcp_trk_idx(rule-&gt;action)]))</span><br><span class="line">        continue;</span><br><span class="line"></span><br><span class="line">      //rule的table会在配置解析的时候，设置为http</span><br><span class="line">      t = rule-&gt;arg.trk_ctr.table.t;</span><br><span class="line">      //到table中查找key，假如不存在会创建新的</span><br><span class="line">      key = stktable_fetch_key(t, sess-&gt;fe, sess, NULL, SMP_OPT_DIR_REQ|SMP_OPT_FINAL, rule-&gt;arg.trk_ctr.expr, NULL);</span><br><span class="line"></span><br><span class="line">      //根据key获取stksess，然后初始化</span><br><span class="line">      if (key &amp;&amp; (ts = stktable_get_entry(t, key)))</span><br><span class="line">        //这里用的是sess-&gt;stkctr的指针，相当于初始化了stkctr[1]</span><br><span class="line">        stream_track_stkctr(&amp;sess-&gt;stkctr[tcp_trk_idx(rule-&gt;action)], t, ts);</span><br><span class="line">           //把需要保存的值累加</span><br><span class="line">           steam_start_counters:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">acl source_is_abuser src_get_gpc0 gt 0:</span><br><span class="line">  src_get_gpc0对应的样本提取函数是：</span><br><span class="line">    smp_fetch_sc_get_gpc0：</span><br><span class="line">      //从stream-&gt;strctr中取stkptr</span><br><span class="line">      //这里在配置文件中，因为src_get_gpc0没有指定table，会默认使用http表，但是因为key是src，所以</span><br><span class="line">      //使用的和上面track-sc1一样的表</span><br><span class="line">      smp_fetch_sc_stkctr：</span><br><span class="line">        if (strm)</span><br><span class="line">          stkptr = &amp;strm-&gt;stkctr[num];</span><br><span class="line">        if (!strm || !stkctr_entry(stkptr)) &#123;</span><br><span class="line">          stkptr = &amp;sess-&gt;stkctr[num];</span><br><span class="line">          if (!stkctr_entry(stkptr))</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return stkptr;</span><br><span class="line">      //从对应的stksess中，取出对应字段gpc0的值</span><br><span class="line">      if (stkctr_entry(stkctr) != NULL) &#123;</span><br><span class="line">        void *ptr = stktable_data_ptr(stkctr-&gt;table, stkctr_entry(stkctr), STKTABLE_DT_GPC0);</span><br><span class="line">        if (!ptr)</span><br><span class="line">          return 0; /* parameter not stored */</span><br><span class="line">        smp-&gt;data.u.sint = stktable_data_cast(ptr, gpc0);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">tcp-request content track-sc2 src </span><br><span class="line">因为上面都没有使用sc2这个变量，所以初始化为strem-&gt;stkctr[2].table = test1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">acl conn_rate_abuse sc2_conn_rate gt 3</span><br><span class="line">从stream-&gt;stkctr[2].table 也就是test1表中取出 conn_rate字段，判断当前值是否大于3</span><br><span class="line"></span><br><span class="line">acl mark_as_abuser sc1_inc_gpc0 gt 0</span><br><span class="line">从stream-&gt;stkctr[1].table 也就是http中取出gpc0的值，然后加1，这个acl始终会返回true</span><br><span class="line"></span><br><span class="line">tcp-request content reject if conn_rate_abuse mark_as_abuser</span><br><span class="line">对于速度大于3的情况，累加http表中gpc0的值，然后拒绝这个连接</span><br><span class="line"></span><br><span class="line">然后这个ip的下一个连接过来时：</span><br><span class="line">acl source_is_abuser src_get_gpc0 gt 0</span><br><span class="line">use_backend ease-up-y0 if source_is_abuser</span><br><span class="line"></span><br><span class="line">从http表中取出gpc0的值，大于1，使用ease-up-y0后端，返回503，直到10m分钟过期以后解除这限制</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Haproxy/">Haproxy</a><a href="/tags/负载均衡/">负载均衡</a></div><div class="post-nav"><a href="/2017/10/08/2017-10-08-haproxy-signal/" class="pre">Haproxy 信号处理</a><a href="/2017/10/06/2017-10-06-haproxy-acl/" class="next">Haproxy acl</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Haprxoy/">Haprxoy</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Https/">Https</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tcp-ip/">tcp/ip</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Haproxy/" style="font-size: 15px;">Haproxy</a> <a href="/tags/负载均衡/" style="font-size: 15px;">负载均衡</a> <a href="/tags/Https/" style="font-size: 15px;">Https</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/dpdk/" style="font-size: 15px;">dpdk</a> <a href="/tags/dpvs/" style="font-size: 15px;">dpvs</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/2018-12-04-netif-init/">dpvs大部分知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/2018-12-04-dpvs-timer/">dpvs timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/02/2018-12-2-kni/">dpdk kni</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/01/2018-12-01-pci-init/">dpdk网卡收发包</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/29/2018-11-29-dpdk-memory/">dpdk 内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/2018-11-26-dpdk-init/">dpdk rte init</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/2018-11-07-numa/">dpdk基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/2018-11-06-dpdk-framework/">dpdk 基本框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/12/2018-04-12-haproxy-port-reuse/">Haproxy 端口复用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/2018-02-26-netfilter/">netfilter 框架及lvs的实现原理</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">天天反水, 美女荷官发牌   ---澳门新葡京.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>