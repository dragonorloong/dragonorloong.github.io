---
title: linux 网桥实现原理
date: 2017-11-07 19:36:14
tags:
    - linux 
    - tcp/ip
description: 本章介绍stp协议的一些关键字， 生成树的过程，以及Linux的实现
comments: true
---
# 生成树协议
stp:
  BPDU: 网桥协议数据单元，用于STP协议的协商
  根网桥： 根网桥是唯一能产生bpdu的网桥，当拓扑发生改变时，根网桥确保网络中的每台网桥都知道此事
  指定网桥： 每个LAN都可以有一个指定网桥，它成为该LAN中所有主机和网桥到达根节点的网桥

  根端口： 网桥所有端口中，通往根网桥的路径开销最低的端口就会被选为根端口
  指定端口： 在每个LAN中，通往根网桥的路径开销最小的端口就会被选为指定端口

  端口状态：
    1 关闭
    2 阻塞
    3 监听
    4 学习
    5 转发

  网桥ID: 每个网桥都会分配一个ID，称为网桥ID，是一个8字节的数，最低的两位是某个网桥端口的MAC地址, 最高两个字节是优先级
  端口ID：每个端口都会被指定一个ID，一部分是根据端口在网桥的总线位置命名，第一个端口指定为1，第二个端口指定为2,端口ID的另外一部分是优先级，值较低的标识有较高优先级, 
        另外端口可以设置一个开销值


  优先级向量： 配额值BPDU的四个元素，根网桥ID，根路径开销，网桥ID以及端口ID

  TCN: 由检测到拓扑变化而且必须通知根网桥的网桥使用, 每隔hello事件发送一个TCN BPDU包给指定网桥，直到收到TCN BPDU的确认包
  TC: 由根网桥使用，当拓扑发生变化时，用于通知其他网桥, 在这段事件内，根网桥发送的BPDU都带上TC标识
  Aging: 用于从转发数据库中清理无效的地址
  HELLO: 每个定时器到期以后，根网桥就会产生一个配置bpdu
  Forward Deplay 定时器: 端口要过这么一段时间才会变成转发状态
  Message Age定时器： 网桥接收到尚未过期的BPDU时，会启动Message Age定时器, 定时器的事件为bpdu的生存期与最大生存期的差值，当这个定时器过期以后，这个端口就会重新指定角色(选择根端口)
  Hold: 配置BPDU的速率限制的定时器
  Short Aging定时器： 当转发数据库的地址一段时间没有数据通过，就会删除, 当收到带有TC标识的BPDU时，启动这个定时器

  收到BPDU配置信息可完成如下工作： 
    1 选出根网桥
    2 选出根端口
    3 对每个端口，为该端口所属的LAN分配指定网桥和指定端口

  根网桥选择：
    每个网桥启动的时候，会认为自己是根网桥，然后在所有的端口上发送BPDU，广播自己是根网桥，别的网桥收到这个BPDU时，假如本地的BPDU副本比收到的BPDU优先级高，就会回复BPDU，
    假如刚开始启动的网桥ID不是优先级最高的网桥，那么最后它肯定会收到一个配置BPDU，里面包含了更高级的根网桥ID，此时，该网桥会接收并记录这些级别较高的信息，相应地更新其端口的状态和角色

  选择根端口：
    根端口的选择就是遍历所有端口，然后选出拥有到达根网桥最佳路径的网桥，假如有两个以上的端口拥有相同的最佳优先级向量，则选择拥有最低端口ID的本地端口作为根端口


  根端口和指定端口是唯一处于转发状态的端口，消除临时环路主要通过forward deplay定时器来保证


 
# linux 网桥实现
  网桥模块初始化
```cpp
  static int __init br_init(void)
  {
    int err;

    //初始化stp相关
    br_stp_sap = llc_sap_open(LLC_SAP_BSPAN, br_stp_rcv);
    if (!br_stp_sap) {
      printk(KERN_ERR "bridge: can't register sap for STP\n");
      return -EADDRINUSE;
    }

    //初始化cam记录内存
    br_fdb_init();

    //防火墙相关的注册
    err = br_netfilter_init();
    if (err)
      goto err_out1;

    //向通知链注册网桥感兴趣的事件
    err = register_netdevice_notifier(&br_device_notifier);
    if (err)
      goto err_out2;

    //netlink初始化
    br_netlink_init();
    //ioctl 初始化
    brioctl_set(br_ioctl_deviceless_stub);
    //设置回调函数，这个在netif_receive_skb中使用
    br_handle_frame_hook = br_handle_frame;

    br_fdb_get_hook = br_fdb_get;
    br_fdb_put_hook = br_fdb_put;

    return 0;

  err_out2:
    br_netfilter_fini();
  err_out1:
    llc_sap_put(br_stp_sap);
    return err;
  }
```

  linux网桥的添加和网卡的差不多, 先调用netdev_alloc申请net_device， 分配私有空间net_bridge结构，指明初始化函数为br_dev_setup，最后register_netdev把该设备注册进内核，br_dev_setup函数主要指定dev->netdev_ops = br_netdev_ops 
  br_add_bridge
  br_add_if

  数据转发: 
```cpp
  netif_receive_skb函数中，在转发给协议栈之前，先调用handle_bridge函数进行桥接相关的处理
  static __inline__ int handle_bridge(struct sk_buff **pskb,
              struct packet_type **pt_prev, int *ret,
              struct net_device *orig_dev)
  {
    struct net_bridge_port *port;

    //假如这个是会换设备，或者设备没有绑定到一个端口上，直接返回
    if ((*pskb)->pkt_type == PACKET_LOOPBACK ||
        (port = rcu_dereference((*pskb)->dev->br_port)) == NULL)
      return 0;

    if (*pt_prev) {
      *ret = deliver_skb(*pskb, *pt_prev, orig_dev);
      *pt_prev = NULL;
    }

    //调用br_handle_frame, 上面桥接系统初始化的时候，已经初始化了
    return br_handle_frame_hook(port, pskb);
  }

  
  int br_handle_frame(struct net_bridge_port *p, struct sk_buff **pskb)
  {
    struct sk_buff *skb = *pskb;
    const unsigned char *dest = eth_hdr(skb)->h_dest;

    if (!is_valid_ether_addr(eth_hdr(skb)->h_source))
      goto err;

    //如果报文的目的地址是01:80:c2:00:00:0X，则是发往STP的多播地址, 调用br_handle_local_finish
    if (unlikely(is_link_local(dest))) {
      skb->pkt_type = PACKET_HOST;
      return NF_HOOK(PF_BRIDGE, NF_BR_LOCAL_IN, skb, skb->dev,
               NULL, br_handle_local_finish) != 0;
    }

    if (p->state == BR_STATE_FORWARDING || p->state == BR_STATE_LEARNING) {
      if (br_should_route_hook) {
        if (br_should_route_hook(pskb))
          return 0;
        skb = *pskb;
        dest = eth_hdr(skb)->h_dest;
      }

      if (!compare_ether_addr(p->br->dev->dev_addr, dest))
        skb->pkt_type = PACKET_HOST;

      NF_HOOK(PF_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
        br_handle_frame_finish);
      return 1;
    }

  err:
    kfree_skb(skb);
    return 1;
  }

  int br_handle_frame_finish(struct sk_buff *skb)
  {
    const unsigned char *dest = eth_hdr(skb)->h_dest;
    struct net_bridge_port *p = rcu_dereference(skb->dev->br_port);
    struct net_bridge *br;
    struct net_bridge_fdb_entry *dst;
    int passedup = 0;

    if (!p || p->state == BR_STATE_DISABLED)
      goto drop;

    /* insert into forwarding database after filtering to avoid spoofing */
    //更新cam数据库
    br = p->br;
    br_fdb_update(br, p, eth_hdr(skb)->h_source);

    if (p->state == BR_STATE_LEARNING)
      goto drop;

    //如果网桥设备处于混杂模式，设置passedup=1，拷贝一份skb
    if (br->dev->flags & IFF_PROMISC) {
      struct sk_buff *skb2;

      skb2 = skb_clone(skb, GFP_ATOMIC);
      if (skb2 != NULL) {
        passedup = 1;
        //给网桥转发一份
        br_pass_frame_up(br, skb2);
      }
    }

    //假如是多播地址，每个端口转发一份
    if (is_multicast_ether_addr(dest)) {
      br->statistics.multicast++;
      br_flood_forward(br, skb, !passedup);
      if (!passedup)
        br_pass_frame_up(br, skb);
      goto out;
    }

    dst = __br_fdb_get(br, dest);
    if (dst != NULL && dst->is_local) {
      if (!passedup)
        br_pass_frame_up(br, skb);
      else
        kfree_skb(skb);
      goto out;
    }

    if (dst != NULL) {
      br_forward(dst->dst, skb);
      goto out;
    }

    br_flood_forward(br, skb, 0);

  out:
    return 0;
  drop:
    kfree_skb(skb);
    goto out;
  }

  static void br_pass_frame_up(struct net_bridge *br, struct sk_buff *skb)
  {
    struct net_device *indev;

    br->statistics.rx_packets++;
    br->statistics.rx_bytes += skb->len;

    //把skb->dev设置成网桥网卡，因为网桥dev->port == NULL, 所以会跳过handle_bridge，进去l3
    indev = skb->dev;
    skb->dev = br->dev;

    NF_HOOK(PF_BRIDGE, NF_BR_LOCAL_IN, skb, indev, NULL,
      netif_receive_skb);
  }

  //无论是单个转发，还是所有端口转发，最后都会调用这个函数
  static void __br_forward(const struct net_bridge_port *to, struct sk_buff *skb)
  {
    struct net_device *indev;

    indev = skb->dev;
    //设置dev为网桥各个port设备
    skb->dev = to->dev;
    skb->ip_summed = CHECKSUM_NONE;

    NF_HOOK(PF_BRIDGE, NF_BR_FORWARD, skb, indev, skb->dev,
        br_forward_finish);
  }

  //最后在br_forward_finish调用dev_queue_xmit函数, 最后调用网卡驱动转发除去
```
