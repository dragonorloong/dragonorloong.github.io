---
title: linux ip协议处理
date: 2017-11-09 19:22:25
tags:
    - linux 
    - tcp/ip
---
  ip头部： ip首部长度20个字节，首部里面有个字段标识首部长度，4位，每位代表4个字节，4为最大表示15, 所以首部长度60个字节，除去20个字节固定长度，ip选项最长40个字节,
      ip校验和只适用于IP报头, 总长度用16位表示，单位是字节，包括报头

  ip选项格式： 

    type字段可以进一步分为三个部分，其中copied被设置时，假如需要分段，则需要把这个选项拷贝到每个片段, length表示整个选项的长度，point可以理解为当前的长度


  ip分段：
    ip头部有两个位用来表示分段相关，DF 禁止分段，MF后面还有分段, OFFSET表示原IP包的偏移量，13位,计算的时候需要左移三位(8字节对齐)
    ID字段是整个ip包都相同的，后续的重组需要使用这个字段。因为源路由根本就不知道有分段等因素，所以丢包的时候，只能把整个包都重新传输一遍，
    并且不会重用之前的ID。

    内核要识别一个片段所属的IP封包，内核会考虑下列参数：
      1 source ip, dest ip
      2 IP封包ID
      3 L4协议


    IP ID生成：
      linux 为每个目的地IP地址使用一个计数器, 遇到NAT的时候，还是有可能重复，导致两个封包都丢弃。 ipv6只允许源头分段，中间路由器不允许分段




  int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
  {
    struct iphdr *iph;
    u32 len;

    /* When the interface is in promisc. mode, drop all the crap
     * that it receives, do not try to analyse it.
     */
    当网卡处于混杂模式时，丢掉所有接收到的的垃圾数据，不要试图解析它

    if (skb->pkt_type == PACKET_OTHERHOST)
      goto drop;

    IP_INC_STATS_BH(IPSTATS_MIB_INRECEIVES);

    //假如引用计数大于1, 拷贝一份
    if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {
      IP_INC_STATS_BH(IPSTATS_MIB_INDISCARDS);
      goto out;
    }

    //保证线性内存中的数据至少可以容纳ip报头大小
    if (!pskb_may_pull(skb, sizeof(struct iphdr)))
      goto inhdr_error;

    iph = skb->nh.iph;

    /*
     *  RFC1122: 3.1.2.2 MUST silently discard any IP frame that fails the checksum.
     *
     *  Is the datagram acceptable?
     *
     *  1.  Length at least the size of an ip header
     *  2.  Version of 4
     *  3.  Checksums correctly. [Speed optimisation for later, skip loopback checksums]
     *  4.  Doesn't have a bogus length
     */
    
    //ip头部至少是20个字节，版本只能等于4
    if (iph->ihl < 5 || iph->version != 4)
      goto inhdr_error;

    //保证ip选项在线性内存中
    if (!pskb_may_pull(skb, iph->ihl*4))
      goto inhdr_error;

    iph = skb->nh.iph;

    //校验ip头部检验和
    if (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))
      goto inhdr_error;

    //报文总长度
    len = ntohs(iph->tot_len);
    if (skb->len < len || len < (iph->ihl*4))
      goto inhdr_error;

    /* Our transport medium may have padded the buffer out. Now we know it
     * is IP we can trim to the true length of the frame.
     * Note this now means skb->len holds ntohs(iph->tot_len).
     */
    //删除可能填充的数据
    if (pskb_trim_rcsum(skb, len)) {
      IP_INC_STATS_BH(IPSTATS_MIB_INDISCARDS);
      goto drop;
    }

    //删除任何控制块碎片
    /* Remove any debris in the socket control block */
    memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));

    //ROUTING相关的操作后面再看，最后会调用ip_rcv_finish
    return NF_HOOK(PF_INET, NF_IP_PRE_ROUTING, skb, dev, NULL,
             ip_rcv_finish);

  inhdr_error:
    IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
  drop:
          kfree_skb(skb);
  out:
          return NET_RX_DROP;
  }
